# Technical Architecture: Project Document Management System

## System Architecture Overview

The Project Document Management System follows Clean Architecture principles with Domain-Driven Design (DDD) to create a maintainable, scalable application. The system is structured in concentric layers, with the domain model at the core and infrastructure concerns at the outer layers.

```
┌─────────────────────────────────────────────────┐
│                                                 │
│  ┌─────────────────────────────────────────┐    │
│  │                                         │    │
│  │  ┌─────────────────────────────────┐    │    │
│  │  │                                 │    │    │
│  │  │  ┌─────────────────────────┐    │    │    │
│  │  │  │                         │    │    │    │
│  │  │  │      Domain Layer       │    │    │    │
│  │  │  │                         │    │    │    │
│  │  │  └─────────────────────────┘    │    │    │
│  │  │       Application Layer         │    │    │
│  │  │                                 │    │    │
│  │  └─────────────────────────────────┘    │    │
│  │           Interface Layer               │    │
│  │                                         │    │
│  └─────────────────────────────────────────┘    │
│               Infrastructure Layer              │
│                                                 │
└─────────────────────────────────────────────────┘
```

The system consists of four primary modules:

1. User & Access Control Module
2. Project Management Module
3. Document Storage & Management Module
4. Information Retrieval & AI Module

## Technology Stack

### Backend
- **Framework**: Spring Boot 3.2.x
- **Language**: Java 17
- **API**: RESTful API with Spring Web
- **Security**: Spring Security with JWT authentication
- **Validation**: Hibernate Validator
- **Testing**: JUnit 5, Mockito, TestContainers

### Frontend
- **Framework**: React 18.x with TypeScript
- **State Management**: Redux Toolkit
- **UI Components**: Material-UI or Chakra UI
- **HTTP Client**: Axios
- **Form Handling**: React Hook Form
- **Testing**: Jest, React Testing Library

### Database
- **RDBMS**: MySQL 8.0
- **Migration**: Flyway
- **ORM**: Spring Data JPA with Hibernate

### Document Storage
- **Local Storage**: File system-based storage with metadata in MySQL
- **Document Processing**: Apache PDFBox, Apache POI, Tika

### Search & AI
- **Search Engine**: Elasticsearch
- **AI Integration**: OpenAI API or Google Gemini API
- **Vector Database**: Milvus or Pinecone for embeddings storage

### DevOps & Infrastructure
- **Containerization**: Docker
- **Orchestration**: Docker Compose (development), Kubernetes (production)
- **CI/CD**: GitHub Actions or Jenkins
- **Monitoring**: Prometheus and Grafana
- **Logging**: ELK Stack (Elasticsearch, Logstash, Kibana)

## Domain Model

The core domain model consists of the following aggregates:

### User Aggregate
- User (root entity)
- Role (value object)
- Permission (value object)

### Project Aggregate
- Project (root entity)
- ProjectMember (entity)
- ProjectRole (value object)
- ProjectStatus (enum: ACTIVE, ON_HOLD, COMPLETED, ARCHIVED)

### Document Aggregate
- Document (root entity)
- DocumentVersion (entity)
- Folder (entity)
- DocumentMetadata (value object)
- DocumentContent (value object)

## Detailed Module Design

### 1. User & Access Control Module

This module handles authentication, authorization, and user management.

#### Components:
- **AuthenticationService**: Manages user login/logout and session handling
- **UserService**: Handles CRUD operations for users
- **RoleService**: Manages role assignments and permissions
- **SecurityConfig**: Configures security policies and JWT handling

#### Database Schema:
```
users (
  id BIGINT PRIMARY KEY,
  email VARCHAR(255) UNIQUE NOT NULL,
  password_hash VARCHAR(255) NOT NULL,
  name VARCHAR(255) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL
)

roles (
  id BIGINT PRIMARY KEY,
  name VARCHAR(50) UNIQUE NOT NULL
)

user_roles (
  user_id BIGINT NOT NULL,
  role_id BIGINT NOT NULL,
  PRIMARY KEY (user_id, role_id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (role_id) REFERENCES roles(id)
)
```

### 2. Project Management Module

This module handles project lifecycle management and project membership.

#### Components:
- **ProjectService**: Handles CRUD operations for projects
- **ProjectMemberService**: Manages project membership and roles
- **ProjectFacade**: Provides a unified interface for project operations

#### Database Schema:
```
projects (
  id BIGINT PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  description TEXT,
  status VARCHAR(20) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  updated_at TIMESTAMP NOT NULL,
  created_by BIGINT NOT NULL,
  FOREIGN KEY (created_by) REFERENCES users(id)
)

project_members (
  project_id BIGINT NOT NULL,
  user_id BIGINT NOT NULL,
  role VARCHAR(50) NOT NULL,
  added_at TIMESTAMP NOT NULL,
  added_by BIGINT NOT NULL,
  PRIMARY KEY (project_id, user_id),
  FOREIGN KEY (project_id) REFERENCES projects(id),
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (added_by) REFERENCES users(id)
)
```

### 3. Document Storage & Management Module

This module handles document storage, organization, and versioning.

#### Components:
- **DocumentService**: Manages document metadata and operations
- **StorageService**: Handles physical file storage and retrieval
- **FolderService**: Manages folder structure and hierarchy
- **VersionService**: Handles document versioning

#### Database Schema:
```
folders (
  id BIGINT PRIMARY KEY,
  project_id BIGINT NOT NULL,
  parent_folder_id BIGINT,
  name VARCHAR(255) NOT NULL,
  created_at TIMESTAMP NOT NULL,
  created_by BIGINT NOT NULL,
  display_order INT NOT NULL DEFAULT 0,
  FOREIGN KEY (project_id) REFERENCES projects(id),
  FOREIGN KEY (parent_folder_id) REFERENCES folders(id),
  FOREIGN KEY (created_by) REFERENCES users(id),
  UNIQUE (project_id, parent_folder_id, name)
)

documents (
  id BIGINT PRIMARY KEY,
  folder_id BIGINT NOT NULL,
  name VARCHAR(255) NOT NULL,
  mime_type VARCHAR(100) NOT NULL,
  size BIGINT NOT NULL,
  created_at TIMESTAMP NOT NULL,
  created_by BIGINT NOT NULL,
  display_order INT NOT NULL DEFAULT 0,
  FOREIGN KEY (folder_id) REFERENCES folders(id),
  FOREIGN KEY (created_by) REFERENCES users(id),
  UNIQUE (folder_id, name)
)

document_versions (
  id BIGINT PRIMARY KEY,
  document_id BIGINT NOT NULL,
  version_number INT NOT NULL,
  storage_path VARCHAR(512) NOT NULL,
  size BIGINT NOT NULL,
  created_at TIMESTAMP NOT NULL,
  created_by BIGINT NOT NULL,
  FOREIGN KEY (document_id) REFERENCES documents(id),
  FOREIGN KEY (created_by) REFERENCES users(id),
  UNIQUE (document_id, version_number)
)
```

### 4. Information Retrieval & AI Module

This module handles document indexing, search functionality, and the AI chatbot.

#### Components:
- **DocumentProcessorService**: Extracts text from documents
- **IndexingService**: Manages the search index
- **SearchService**: Handles document search operations
- **ChatbotService**: Processes user queries and generates responses
- **EmbeddingService**: Creates and manages vector embeddings

#### Database Schema:
```
document_content (
  id BIGINT PRIMARY KEY,
  document_version_id BIGINT NOT NULL,
  content_text LONGTEXT,
  indexed_at TIMESTAMP,
  embedding_status VARCHAR(20) DEFAULT 'PENDING',
  FOREIGN KEY (document_version_id) REFERENCES document_versions(id)
)

chatbot_conversations (
  id BIGINT PRIMARY KEY,
  user_id BIGINT NOT NULL,
  project_id BIGINT,
  started_at TIMESTAMP NOT NULL,
  last_message_at TIMESTAMP NOT NULL,
  FOREIGN KEY (user_id) REFERENCES users(id),
  FOREIGN KEY (project_id) REFERENCES projects(id)
)

chatbot_messages (
  id BIGINT PRIMARY KEY,
  conversation_id BIGINT NOT NULL,
  message_type VARCHAR(10) NOT NULL,
  content TEXT NOT NULL,
  sent_at TIMESTAMP NOT NULL,
  FOREIGN KEY (conversation_id) REFERENCES chatbot_conversations(id)
)

chatbot_references (
  id BIGINT PRIMARY KEY,
  message_id BIGINT NOT NULL,
  document_id BIGINT NOT NULL,
  relevance_score FLOAT NOT NULL,
  FOREIGN KEY (message_id) REFERENCES chatbot_messages(id),
  FOREIGN KEY (document_id) REFERENCES documents(id)
)
```

## API Structure

The REST API is organized around resources and follows RESTful principles:

### Authentication Endpoints
- `POST /api/auth/login` - User login
- `POST /api/auth/logout` - User logout
- `POST /api/auth/refresh` - Refresh authentication token

### User Management Endpoints
- `GET /api/users` - List users
- `GET /api/users/{id}` - Get user details
- `POST /api/users` - Create user
- `PUT /api/users/{id}` - Update user
- `DELETE /api/users/{id}` - Delete user

### Project Management Endpoints
- `GET /api/projects` - List projects
- `GET /api/projects/{id}` - Get project details
- `POST /api/projects` - Create project
- `PUT /api/projects/{id}` - Update project
- `DELETE /api/projects/{id}` - Delete project
- `POST /api/projects/{id}/archive` - Archive project
- `POST /api/projects/{id}/unarchive` - Unarchive project

### Project Membership Endpoints
- `GET /api/projects/{id}/members` - List project members
- `POST /api/projects/{id}/members` - Add member to project
- `PUT /api/projects/{id}/members/{userId}` - Update member role
- `DELETE /api/projects/{id}/members/{userId}` - Remove member from project

### Document Management Endpoints
- `GET /api/projects/{id}/folders` - List root folders
- `GET /api/folders/{id}/contents` - List folder contents
- `POST /api/folders` - Create folder
- `PUT /api/folders/{id}` - Update folder
- `DELETE /api/folders/{id}` - Delete folder
- `POST /api/documents/upload` - Upload document
- `GET /api/documents/{id}` - Get document metadata
- `GET /api/documents/{id}/download` - Download document
- `GET /api/documents/{id}/versions` - List document versions
- `DELETE /api/documents/{id}` - Delete document

### Search & Chatbot Endpoints
- `GET /api/search` - Search documents
- `POST /api/chatbot/conversations` - Start new conversation
- `GET /api/chatbot/conversations/{id}/messages` - Get conversation messages
- `POST /api/chatbot/conversations/{id}/messages` - Send message to chatbot

## Implementation Strategy

### Document Storage Implementation

The system will use a local file system for document storage with the following structure:

```
/storage
  /projects
    /{project_id}
      /{document_id}
        /{version_number}.{extension}
```

The StorageService will handle file operations with the following methods:

```java
public interface StorageService {
    String storeFile(MultipartFile file, Long projectId, Long documentId, Integer version);
    Resource loadFileAsResource(String storagePath);
    void deleteFile(String storagePath);
}
```

### Document Indexing Pipeline

The document indexing process follows these steps:

1. Document uploaded → DocumentUploadedEvent triggered
2. DocumentProcessorService extracts text content based on document type
3. IndexingService processes the extracted text and stores it in Elasticsearch
4. EmbeddingService generates vector embeddings for the document content
5. Embeddings stored in vector database for semantic search

### Chatbot Implementation

The chatbot uses Retrieval-Augmented Generation (RAG) with the following flow:

1. User submits a question
2. Question is converted to an embedding vector
3. Vector similarity search finds relevant document chunks
4. Retrieved chunks and the original question are sent to the LLM API
5. LLM generates a response based on the provided context
6. Response and source references are returned to the user

```java
public class ChatbotService {
    public ChatbotResponse processQuery(String query, Long projectId, Long userId) {
        // Convert query to embedding
        float[] queryEmbedding = embeddingService.createEmbedding(query);
        
        // Find relevant documents
        List<DocumentMatch> matches = vectorSearchService.findSimilarDocuments(
            queryEmbedding, projectId, 5);
        
        // Extract content from matches
        String context = documentContentService.extractContentFromMatches(matches);
        
        // Generate response using LLM
        String response = llmService.generateResponse(query, context);
        
        // Return response with references
        return new ChatbotResponse(response, matches);
    }
}
```

## Security Considerations

### Authentication & Authorization

The system uses JWT (JSON Web Tokens) for stateless authentication with the following security measures:

- Tokens expire after 30 minutes
- Refresh tokens with 7-day expiry for extended sessions
- Role-based access control for authorization
- CORS configuration to restrict API access

### Document Access Control

Document access is controlled through project membership:

- Users can only access documents from projects they are members of
- Document operations are restricted based on project role
- All document access attempts are logged for audit purposes

### API Security

The API implements several security measures:

- Rate limiting to prevent abuse
- Input validation to prevent injection attacks
- HTTPS enforcement for all communications
- Secure headers (Content-Security-Policy, X-XSS-Protection, etc.)

## Performance Considerations

### Database Optimization

- Proper indexing on frequently queried columns
- Connection pooling for efficient database connections
- Query optimization for complex operations
- Pagination for large result sets

### Document Processing

- Asynchronous processing of document uploads
- Batch processing for indexing operations
- Caching of frequently accessed documents
- Progressive loading for large documents in the UI

### Search Optimization

- Efficient indexing strategies in Elasticsearch
- Query optimization for search operations
- Caching of search results
- Asynchronous index updates

## Deployment Architecture

The system is deployed using Docker containers orchestrated with Docker Compose (development) or Kubernetes (production).

```
┌─────────────────────────────────────────────────────────────┐
│                      Load Balancer                          │
└───────────────────────────────┬─────────────────────────────┘
                                │
┌───────────────────────────────┼─────────────────────────────┐
│                               │                             │
│  ┌─────────────────┐    ┌─────┴───────────┐                 │
│  │  API Service    │    │  API Service    │                 │
│  │  (Container)    │    │  (Container)    │                 │
│  └────────┬────────┘    └────────┬────────┘                 │
│           │                      │                          │
│  ┌────────┴────────────┬────────┴────────┐                  │
│  │                     │                 │                  │
│  ▼                     ▼                 ▼                  │
│ ┌──────────┐     ┌──────────┐     ┌──────────────┐         │
│ │  MySQL   │     │ Elastic- │     │ Vector DB    │         │
│ │          │     │ search   │     │ (Milvus)     │         │
│ └──────────┘     └──────────┘     └──────────────┘         │
│                                                            │
│ ┌──────────────────────────────────────────────┐           │
│ │              Shared Storage                  │           │
│ │              (Document Files)                │           │
│ └──────────────────────────────────────────────┘           │
│                                                            │
└────────────────────────────────────────────────────────────┘
```

## Frontend Architecture

The React frontend follows a component-based architecture with the following structure:

```
src/
├── api/               # API client and services
├── components/        # Reusable UI components
│   ├── common/        # Generic components
│   ├── documents/     # Document-related components
│   ├── projects/      # Project-related components
│   └── users/         # User-related components
├── contexts/          # React contexts for state sharing
├── hooks/             # Custom React hooks
├── layouts/           # Page layout components
├── pages/             # Page components
├── redux/             # Redux store, slices, and actions
├── types/             # TypeScript type definitions
└── utils/             # Utility functions
```

Key frontend patterns include:

- Container/Presentational component pattern
- Custom hooks for shared logic
- Redux for global state management
- React Router for navigation
- Error boundaries for graceful error handling

## Development and Testing Strategy

### Development Workflow

1. Feature branches with Git Flow workflow
2. Pull request reviews before merging
3. Continuous integration with automated tests
4. Linting and code formatting enforcement

### Testing Approach

- **Unit Testing**: Test individual components and services
- **Integration Testing**: Test interactions between components
- **API Testing**: Test API endpoints with realistic scenarios
- **UI Testing**: Test user interfaces with React Testing Library
- **End-to-End Testing**: Test complete user flows with Cypress

## Monitoring and Maintenance

### Logging Strategy

- Structured logging with contextual information
- Log aggregation with ELK stack
- Log levels (DEBUG, INFO, WARN, ERROR) for filtering
- Request tracing for distributed operations

### Monitoring

- Health check endpoints for service status
- Prometheus metrics for performance monitoring
- Grafana dashboards for visualization
- Alerting for critical issues

### Backup Strategy

- Regular database backups
- Document storage backups
- Backup verification and restoration testing
- Disaster recovery planning

## Conclusion

This architecture provides a comprehensive foundation for building the Project Document Management System. The clean architecture approach with domain-driven design ensures separation of concerns and maintainability, while the chosen technologies offer a balance of performance, scalability, and developer productivity. The modular design allows for independent development and testing of each component, facilitating a smooth implementation process. 